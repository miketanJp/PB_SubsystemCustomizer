# Phantom Brigade<br>Subsystem Customizer Tool

**Author:** Michele Paolucci A.K.A. MiketanJp<br>
**Version:** 1.1.0 (TBD)<br>
**Programming language:** Java Development Kit v17.0.14 (Liberica JDK)<br>
**Framework(s) used:** JavaFX SDK v21.0.5, Snakeyaml v2.2<br>
**Requirements**: JRE 21.0.5 (please install JDK 21.0.5 to run it; required JRE is embedded with JDK)<br>
**License:** BSD-3 Clause<br>

## Tool description 
A tool designed to easily create custom weapon stats for Phantom Brigade, a hybrid turn-based mech game developed by Brace Yourself Games.
The program is specifically designed for modders and players who want to quickly and easily customize the stats of a given subsystem weapon, without having to directly the subsystem config file or accessing to Mod SDK solely for this purpose.


## Subsystem stats üìí
Below list explains the available weapon subsystem stats that can be modified through the tool:<br>
- **projectile magazine (`act_count`)** ‚Üí the number of projectiles fired in a single shot
- **projectile duration (`act_duration`)** ‚Üí Subsystem duration in the timeline in seconds. The higher the value, the longer the weapon will be used (eg higher value means you will use it even in the next turn, either partially or completely).
- **Subsystem Heat (`act_heat`)** ‚Üí The heat generated by the system when used. The higher the value, the quicker it will overheat in one turn.
- **Subsystem Mass (`mass`)** ‚Üí Subsystem mass. The higher the value, the slower the mech will move when equipped.
- **Scrap value (`scrap_value`)** ‚Üí The amount of resources the subsystem will yield when scrapped.
- **Projectile Concussion (`wpn_concussion`)** ‚Üí Concussion power dealt by the projectile. The higher the value, more powerful the concussion power will be to neutralize the enemy pilot.
- **Projectile Damage (`wpn_damage`)** ‚Üí Damage amount dealt by the projectile. The higher the value, the more damage it will deal to the enemy mech.
- **Projectile Damage radius (`wpn_damage_radius`)** ‚Üí Projectile damage radius. The higher the value, the more area will be covered by the damage (useful if you want to make AoE weapons).
- **Projectile Impact  (`wpn_impact`)** ‚Üí Impact damage dealt by the projectile. The higher the value, the more impact damage dealt onto the environment upon the weapon shot.
- **Projectile Impact radius (`wpn_impact_radius`)** ‚Üí Projectile impact radius. The higher the value, the more area will be covered by the impact damage (useful if you want to make AoE weapons).
- **Projectile lifetime (`wpn_proj_lifetime`)** ‚Üí Projectile lifetime. Determines how long the projectile will last before disappearing.
- **Projectile ricochet (`wpn_proj_ricochet`)** ‚Üí Projectile ricochet. Setting up an higher value means it will have a higher chance to ricochet against units/environment.
- **Subsystem minimum range (`wpn_range_min`)** ‚Üí Subsystem minimum range. It determines the minimum range needed to the weapon to have the best accuracy (in meters).
- **Subsystem maximum range (`wpn_range_max`)** ‚Üí Subsystem maximum range. It determines the maximum range within which the weapon can get the best accuracy (in meters).
- **Subsystem scatter angle (`wpn_scatter_angle`)** ‚Üí Subsystem scatter angle when in idle position. Higher value can make the subsystem fires in a wider angle, therefore making it less accurate. An exception would be if the subsystem is a shotgun, where a higher value means a wider spread of projectiles.
- **Subsystem scatter angle in movement (`wpn_scatter_angle_moving`)** ‚Üí Subsystem scatter angle when the unit is moving. Higher value can make the subsystem fires in a wider angle in movement, making it less accurate.
- **Projectile speed (`wpn_speed`)** ‚Üí Projectile speed. The higher the value, the faster the projectile will reach the target. Interesting use case if the custom subsystem needs to be a high-speed burst rifle or performant SMGs with a higher fire ratio.

Each field will always be shown as Integer data type, unless otherwise specified. Eventually can be edited as float by hand, but for convenience the serializer will convert the number as integer.

## Tool feature(s) üõ†Ô∏è
At the moment, the Subsystem Customizer will let the user make the following actions in order to create a custom subsystem stats set:<br>

- **Save** ‚Üí The serializer will save the portion of the stats in a YAML file, which can be used to eventually create several copies or temporarly save the stats for later use. It can be saved in a destination of your choice, and the file name with extension will be saved automatically, as there's no need to be explicitely specified.
- **Import** ‚Üí The serializer will load the YAML file previously saved. It will fill the fields with the values contained in the file directly into the fields in the tool. The file must be a valid YAML file with the correct indentation and values, otherwise the serializer will not be able to load it.
- **Copy to clipboard** ‚Üí It will copy the values into the clipboard, ready to use. Useful if you want to directly copy-paste the values into the config file for quick-testing.

## YAML field structure üíª
Regardless of the save or copying to clipboard feature, the input values will be serialized in a ready-to-use YAML indentation, with no intevention from the user:
```yaml
stats:
  act_count:
    value: 1
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  act_duration:
    value: 2
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  act_heat:
    value: 3
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  mass:
    value: 4
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  scrap_value:
    value: 5
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_concussion:
    value: 6
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_damage:
    value: 7
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_damage_radius:
    value: 8
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_impact:
    value: 9
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_impact_radius:
    value: 10
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_proj_lifetime:
    value: 11
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_proj_ricochet:
    value: 12
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_range_max:
    value: 13
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_range_min:
    value: 14
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_scatter_angle:
    value: 15
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_scatter_angle_moving:
    value: 16
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
  wpn_speed:
    value: 17
    targetMode: 0
    targetSocket: ''
    targetHardpoint: ''
```
Except `value` field, all the fields are set to `0` and `' '` by default and can eventually be changed from the user if needed. `targetMode`, `targetSocket` and `targetHardpoint` fields are not used in this tool, but they are required to respect the YAML structure. The serializer will always set them to 0 and empty string respectively as there are no important values to be set. The user can edit them manually outside the tool if possesses the required knowledge about editing said fields.
`stats` is the main block that contains all the nested field inside of it and must remain empty. On back-end, the serializer will handle each field and nesting with `HashMap` for the YAML structure to be created correctly in terms of _Key-value pairs_.<br>
**Note:** in order for the serializer to work correctly on the Import feature, the file must respect the above mentioned structure and indentation. The tool may not be able to load the file if the indentation is not correct.

## Tool installation / Development setup ‚öôÔ∏è
The project is developed using **Java Development Kit v21.0.5** and **JavaFX SDK v17.0.14**. It is highly recommended to import the project with IntelliJ IDEA (Community Edition) to avoid issues and/or errors upon import.<br>

To compile the application, it is crucial to download **OpenJFX SDK v17.0.14** and configured in the project, as JavaFX is no more bundled starting from **JDK 11** onward. You can download Javafx SDK from [JavaFX SDK website](https://gluonhq.com/products/javafx/).<br>

### Compiling
To create a standalone executable, you first need to create a JAR file with the following maven command:<br>
`mvn clean package`<br>
Alternatively, launching the following goal will create just one jar to the `target` folder<br>
`mvn assembly:single`<br>

The first command will create the source classes and two versions of the JAR file.
<br>The following filename of the above-mentioned JAR files are **${jarName}-${version}.jar** and **${jarName}-${version}-jar-with-dependencies.jar** respectively. The first one is for development, while the second one is the production version with the embedded dependencies needed to run as a standalone application.<br>

To create a functional windows application (.exe) of this tool, you need to use **Launch4j**. You can download it from [Launch4j website](http://launch4j.sourceforge.net/).<br> Once downloaded, you can load the `pbSubsystemCustomizer.xml` file inside `configs` folder to load the configuration needed to create the executable file.<br>
<br>Make sure to point to the JDK and JavaFX folder correctly, otherwise the executable will not work. The output file will be created in the target folder (the same as the compiled JAR file). The Launch4j configuration file has only relative paths for obvious reasons, as well as giving the developer hints about which path to tweak.<br>

### Running the tool
To run the compiled executable, you need to have the JRE installed on your system. <br>
**Java Development Kit** is required to have the compatible JRE the tool requires.

If you install JDK for the first time, please check if related JRE is installed as well.
Once set up on your system, check it by launching the following command in your terminal:<br>

`java --version`<br>

The terminal will then output the installed version on your system (pointed up on %JAVA_HOME% system variable). The output will then return something like this:<br>
`Java(TM) SE Runtime Environment (build 17.0.15)`

if you see the above output, it means JRE is installed and you can safely run the tool.